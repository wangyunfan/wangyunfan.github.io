<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="着手第一个IOS应用 : ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>着手第一个IOS应用</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/wangyunfan">View on GitHub</a>

          <h1 id="project_title">着手第一个IOS应用</h1>
          <h2 id="project_tagline"></h2>

        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="马上着手开发ios应用程序" class="anchor" href="#%E9%A9%AC%E4%B8%8A%E7%9D%80%E6%89%8B%E5%BC%80%E5%8F%91ios%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F" aria-hidden="true"><span class="octicon octicon-link"></span></a>马上着手开发IOS应用程序</h1>

<h2>
<a id="创建第一个单视图应用" class="anchor" href="#%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%95%E8%A7%86%E5%9B%BE%E5%BA%94%E7%94%A8" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建第一个单视图应用<br>
</h2>

<h3>
<a id="main-方法" class="anchor" href="#main-%E6%96%B9%E6%B3%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>main 方法</h3>

<hr>

<pre><code>int main(int argc, char * argv[]) {
    @autoreleasepool {
    return UIApplicationMain(argc, argv, nil,   NSStringFromClass([AppDelegate class]));
    }
}
</code></pre>

<p><strong>创建了两个重要初始化组件</strong></p>

<h4>
<a id="1--uiapplication-类的实例--应用程序对象--" class="anchor" href="#1--uiapplication-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B--%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AF%B9%E8%B1%A1--" aria-hidden="true"><span class="octicon octicon-link"></span></a>1 : UIApplication 类的实例 －－》 应用程序对象  <br>
</h4>

<h4>
<a id="2--appdelegate-类的实例---应用程序委托-" class="anchor" href="#2--appdelegate-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B---%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%A7%94%E6%89%98-" aria-hidden="true"><span class="octicon octicon-link"></span></a>2 : AppDelegate 类的实例  －－》 应用程序委托 <br>
</h4>

<p>委托中包含了 window单一属性，继承与 OSX 而来。 <br></p>

<p>实现中的方法为默认，会在恰当的时机自动触发，无论删除与否。<br></p>

<blockquote>
<p>创建IB文件，IB文件与Iphone实际大小不符解决方法：
 <strong>InterfaceBuilderDocument</strong> 中 UseSizeClasses 复选框    </p>
</blockquote>

<h2>
<a id="需求分析要点" class="anchor" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E8%A6%81%E7%82%B9" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析要点</h2>

<p>*** 1:将概念转化为设计并实现该设计 ***  </p>

<p>*** 2:事件驱动编程 ***</p>

<h2>
<a id="关于面向对象" class="anchor" href="#%E5%85%B3%E4%BA%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1" aria-hidden="true"><span class="octicon octicon-link"></span></a>关于面向对象</h2>

<p>1、一切均为对象<br>
2、类是对象的蓝图（类定义了对象的行为与属性）</p>

<blockquote>
<p>人的行为有 睡觉、吃饭、写代码<br>
 人的属性有 身高、体重、写代码</p>
</blockquote>

<pre><code>    创建特定类的实例来新建对象
    途径就是为对象分配并初始化  
</code></pre>

<p>3、<strong>对象通过消息发送</strong>  </p>

<blockquote>
<p>在Objective－C术语中，一个对象通过调用另一个对象的方法来向对象发送消息。 </p>
</blockquote>

<pre><code>[somePerson sayHello];
</code></pre>

<p>左侧的引用somePerson是消息的接收者，右侧的消息sayHello是调用其方法的名称，－－》<em>执行这段代码时 会向somePerson发送sayHello消息</em></p>

<p>4、协议？？</p>

<h2>
<a id="定义交互" class="anchor" href="#%E5%AE%9A%E4%B9%89%E4%BA%A4%E4%BA%92" aria-hidden="true"><span class="octicon octicon-link"></span></a>定义交互</h2>

<p>1.导航控制器 管理的一组视图控制器称为导航栈</p>

<p>2.过渡方式包括  Push（目的视图<strong>控制器</strong>添加到导航栈）、Modal（模态方式显示另一个控制器）、Custom（<strong>UIStoryBoaedSegue</strong>子类化）、Unwind（反向导航）</p>

<p>3.采用Auto Layout布局约束</p>

<p>4.创建场景注意<em>初始化</em>场景指示器 ---&gt;<strong><em>应用程序启动时载入的首个场景</em></strong></p>

<p>5.MVC图示 <img src="https://developer.apple.com/library/ios/referencelibrary/GettingStarted/RoadMapiOSCh/Art/ModelViewController_c_2x.png%20=380x125" alt="MVC icon"></p>

<p>6.在串联图（IB）中构建的每个内容视图层次均需要一个对应的视图控制器来管理界面元素&amp;执行任务响应用户的交互操作。<strong>视图控制器最主要的作用是响应用户输入</strong></p>

<p>7.视图控制器与串联图中的视图通信方法－－》<em>Action</em>与<em>Outlet</em></p>

<p>8.操作（Action） 是与应用程序中可能会发生的某类事件链接，该事件会触发此代码段。定义方法是使用<em>IBAction</em>返回类型和<em>sender</em>参数来创建并执行。</p>

<pre><code>- (IBAction)restoreDefaults:(id)sender;
</code></pre>

<p>sender参数指向负责触发操作的对象；IBAction返回类型与void类似，表示该方法是一种操作。</p>

<p>9.输出口（Outlet） 可以从代码文件引用界面中的对象（添加到串联图的对象），按住Control将特定对象拖至视图控制器即可创建，即为视图控制器中的文件创建属性，<code>可通过代码在运行时来访问并操控该对象。</code></p>

<p><em>Outlet被定义为IBOut属性</em></p>

<pre><code>@property (werk,nonatomic) IBoutlet UITextField *textField
</code></pre>

<p>10.控制（Control） 即用户界面对象（按钮、滑块等），用户可以操控他们来与内容进行交互等操作，<code>代码可通过控制来接收用户界面的消息</code></p>

<p>用户与控制进行交互会创建<em>用户事件</em>，常见的事件类型如 触碰和拖移、编辑事件、值更改事件。</p>

<blockquote>
<p>定义交互时，应了解与应用中每个控制相关联的操作，然后明确向用户展示应用中控制的操作。</p>
</blockquote>

<p>11.导航控制器（UINavigationController），应用中多个内容视图层次进行切换，即可使用导航控制器，<code>导航控制器管理一系列视图控制器向前和向后切换的操作</code>.</p>

<p><strong>导航控制器管理的一组视图称导航栈&lt;栈特性&gt;，添加到栈的第一个项目为根视图控制器，永不会从堆栈中弹出，其他视图控制器可被压入或弹出导航栈</strong></p>

<p>导航控制器不仅管理内容视图控制器的显示方式，还负责显示自己的自定视图，包含一个返回按钮和其他可以自定的按钮，添加到导航栈的每个视图控制器都会显示这个导航栏</p>

<blockquote>
<p>导航控制器会提供返回按钮并实现操作，但需要手动将视图控制器压入堆栈中</p>
</blockquote>

<p>12.使用串联图来定义导航</p>

<p>通常情况，串联图由一系列场景组成，每个场景表示一个视图控制器及其视图层次。场景由<strong><em>过渡</em></strong>连接<br>
 <code>源视图控制器－-*过渡*-－&gt;目的视图控制器。</code></p>

<p>几种过渡类型：</p>

<ul>
<li><p>Push 将目的视图控制器添加到导航栈，只有源视图控制器与导航控制器连接时才可使用。</p></li>
<li><p>Modal 就是一个视图控制器以模态的方式显示另一个控制器，需用户在显示的控制器上执行某种操作，然后返回到应用程式主流程。Modal不会添加到导航栈，通常被认为是所显示的视图控制器的字视图控制器</p></li>
<li>Custom 可以通过将UIStoryboardSegue子类化定义自定过渡。</li>
<li>Unwind 通过向后移动一个或多个过渡，让用户返回到视图控制器的当前实例，可以实现反向导航。</li>
</ul>

<h2>
<a id="串联图" class="anchor" href="#%E4%B8%B2%E8%81%94%E5%9B%BE" aria-hidden="true"><span class="octicon octicon-link"></span></a>串联图</h2>

<p>1.采用Auto Layout
使用<em>约束</em>规则描述意图，应当如何放置一个元素以及与另一个元素相关联、元素应有的大小等。</p>

<p>在画布上，按住Control向四个方向的顶部（父视图）分别拖拽，停止拖移操作时，选取“Top Space to Top Layout Guide”创建间距约束。</p>

<p>2.创建第二场景</p>

<p>将想要添加的视图控制器拖至串联图（IB），可能需要将新场景设定为初始场景。可以选择“Is Initial View Controller”复选框，也可以将初始化场景指示器拖到目标视图控制器。</p>

<p>3.在表格视图中显示静态内容</p>

<p>在Attributes中  Content的弹出式菜单中选择StaticCells</p>

<blockquote>
<p>Push导航设计用于深层次界面，即无论用户选定哪一项，都能为其提供更多相关信息。</p>

<p>添加项目是一种模态操作，即用户执行某个完整且自包含的操作，然后从场景返回到主导航，此类表述方式为<strong><em>modal</em></strong>过渡</p>
</blockquote>

<p>4.创建自定视图控制器</p>

<p>将类识别为某个场景的视图控制器。在ViewController中的Identity检查器中，打开“Class”选项的弹出式菜单，选取自定义类。</p>

<p>5.跳转过渡以返回</p>

<p>unwind过渡，此过渡允许用户从一个给定场景返回上一个场景，并提供位置添加代码，以在用户导航切换场景时执行。</p>

<p>通过向目的视图控制器（要跳转<strong><em>到</em></strong>的视图控制器）添加方法，创建unwind过渡。可以跳转到的方法必须返回一个操作（IBAction），并且在串联图过渡（UIStoryboardSegue）中作为参数采用。</p>

<p>在接口文件（.h）中</p>

<pre><code> -(IBAction) unwindXXX:(UIStoryboardSegue *)segue;
</code></pre>

<p>在实现文件（.m）中</p>

<pre><code> -(Action) unwindXXXX:(UIStoryboardSegue *)segue
 {

 }
</code></pre>

<blockquote>
<p>跳转操作命名为目的位置，让操作返回的位置一目了然。</p>
</blockquote>

<p>若要创建unwind过渡，通过源视图控制器场景台中的“Exit”图标，将按钮链接到unwindXXXc:操作</p>

<p><em>表格视图有两种获取数据的方式，即静态获取或动态获取。当表格视图的控制器实现所要求的UITableViedDataSource方法时，表格视图将向其视图控制器请求数据以进行显示，不管IB中是否配置了静态数据。</em></p>

<h2>
<a id="整合数据" class="anchor" href="#%E6%95%B4%E5%90%88%E6%95%B0%E6%8D%AE" aria-hidden="true"><span class="octicon octicon-link"></span></a>整合数据</h2>

<p>应用程序的<em>数据模型</em>由数据结构和自定业务逻辑组成；自定业务逻辑是让数据保持一直状态所必要的。</p>

<p>1.模型设计</p>

<p>如果储存的数据很小，Foundation框架是最佳选择。如果数据模型不紧要存储数据，还要求自定业务逻辑，可以编写一个自定类。</p>

<ul>
<li>需要存储哪种类型的数据；</li>
<li>可以使用哪种数据结构；使用框架 or 定义自定功能类</li>
<li>如何将数据提供给用户界面；模型不应直接与界面通信 </li>
</ul>

<p>2.模型实现</p>

<p>开发数据模型，最重要目标是能正常运行，开始实现之后，要勇于反复重做和改进模型。</p>

<h2>
<a id="使用设计模式" class="anchor" href="#%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用设计模式</h2>

<p>1.目标－操作</p>

<p>特定事件发生时，一个对象会向另一个对象发送消息。<em>操心信息</em>就是在源代码中定义的选择器，<em>目标</em>（即接受信息的对象）则是能够执行该操作的对象（通常为视图控制器）。发送操作信息的对象通常为控制。</p>

<p>2.委托（?）</p>

<p>应用程序中的一个对象代表另一个对象，或者与另一个对象协调工作。授权对象保留对另一个对象（委托对象）的引用，并适时向委托对象发送信息。该信息会告诉事件的委托对象，授权对象即将处理或刚处理了某个时间。委托对象可能会对该信息作出如下响应：更新其本身或应用程序中其他对象的外观或状态，在某些情况下，他会返回一个值来反映待处理的事件该如何处理。</p>

<h2>
<a id="处理foundation" class="anchor" href="#%E5%A4%84%E7%90%86foundation" aria-hidden="true"><span class="octicon octicon-link"></span></a>处理Foundation</h2>

<p>Foundation框架包括表示基本数据类型的值类（字符串和数字）以及用于储存其他对象的集（conllection）类。</p>

<p>1.值对象</p>

<p><em>值对象</em>指封装了基本值且提供了与该值相关的服务的对象。</p>

<p>可以从基本类型的数据创建值对象。之后可通过代码从该对象访问被封装的数据。</p>

<pre><code>int n = 5;
NSNumber *number = [NSNumber numberWithInt : n];
int y = [number intValue];
</code></pre>

<p>大多数值类会通过声明初始化程序和类工厂方法来创建实例。类工厂方法由类实施，作为提供给客户的简单方法；它将分配和初始化结合为一个步骤，并返回已创建的对象。</p>

<p>2.集对象</p>

<p>Objective－C代码中的大多数集对象都是一种基础集类（NSArray、NSSet和NSDictionary）的实例。这些类用于管理对象组，因此要添加到集（collection）中的任何项目都必须是Objective—C类的实例，如果要添加标量值，就必须先创建合适的NSNumber实例表示。</p>

<p><em>添加进集的任何对象的生命周期都将不短于集。因为集类会使用强引用来跟踪其内容</em></p>

<p>3.数组</p>

<p>数组用于表示有序的对象列表。如果要保持数组中的顺序，每个元素都应储存在从0开始的索引中。</p>

<ul>
<li>
<p>创建数组
根据对象的数量不同，可用的初始化和工厂方法也不同</p>

<pre><code>+(id)arrayWithObject:(id) anObject;
+(id)arrayWithObjects:(id)firstObject,..;
-(id)initWithObjects:(id)firstObject,..;
</code></pre>

<p>由于arrayWithObjects和initWithObjects方法都采用以nil结束且数量可变的参数，所以必须包括nil并将其作为最后一个值。如果所提供的其中一个值为nil，则有可能使项目列表意外截断。</p>
</li>
<li>
<p>排序数组对象</p>

<p>NSArray 类提供了多种方法对其收集的对象进行排序。由于 NSArray 是不可变的，因此这类方法都会返回新的数组，并在其中包含排好序的项目。</p>

<p>例如，您可以通过在每个字符串上调用 compare:，对字符串数组进行排序。</p>
</li>
</ul>

<p>4.集合</p>

<p>集合对象与数组类似，只是其中包含的是各种无序的对象。所以测试成员资格时，集合比数组更快。</p>

<p>5.字典</p>

<p>字典会储存与给定键相关的对象，用于以后的检索，最佳实践是字符串对象用作字典键，其他对象也可以用，但是每个键都会被拷贝供字典使用并且必须支持NSCopying。</p>

<p>6.使用NSNull表示nil</p>

<p>在Objctive－C中，nil表示“无对象”，因此不能将nil添加到集类，如果要在集类中表示“无对象”，应使用NSNull类。</p>

<pre><code>    NSArray *array ＝ @［@“String”，@42，［NSNull null］］；
</code></pre>

<h2>
<a id="编写自定类" class="anchor" href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E7%B1%BB" aria-hidden="true"><span class="octicon octicon-link"></span></a>编写自定类</h2>

<p>IOS的“时钟”应用程序中的“世界时钟”标签，比起标准表格视图单元格，此表格视图中的单元格需要显示更多内容，可以扩展UITableViewCell的行为来扩展内容。</p>

<p>1.声明并实现类</p>

<p>类的说明需要两个不同的部分：接口和实现。<strong>接口</strong>准确指定了一个给定类型的对象，如何专用于其他对象。这个<strong>实现</strong>包括的可执行代码，涵盖了接口中声明的每个方法。</p>

<p>2.储存对象的数据的属性</p>

<p>属性声明在接口文件内部。如下所示：</p>

<pre><code>@interface ToDoItem ： NSObject；

@property NSString *itemName；
@property （readonly）NSDate *creationDate；

@end
</code></pre>

<p>其中creationDate这个属性不可更改。如果属性是私有的，将其声明放在实现文件顶部的<em>类扩展</em>中。</p>

<p>3.方法用来定义对象的行为</p>

<p>可以将方法添加到类接口，在类实现中实现该方法的行为。</p>

<blockquote>
<p>方法名称前面的（－）代表他是实例方法，可以用该类的对象调用。类方法用（＋）表示，类方法可通过类本身调用。类方法的常见示例是类工厂方法。</p>
</blockquote>

<p>4.方法参数</p>

<p>通过名称引用带一个参数的方法时，冒号将作为方法名称的一部分，如果方法有多个参数，那么它会被分解，并插入参数名称。</p>

<p>5.实现方法</p>

<p>与属性一样，方法也可以是私有的或者公共的。</p>

<p>Objective-C、Foundation框架与Xcode部分结束。</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
